Para que mi código lo mejore de manera eficiente la IA aplique dos prompt:

Primer Promtp =

Necesito que me ayudes a mejorar este codigo de la manera mas eficiente posible sigueinte las intrucciones que se encuentran en el parentesis (En una editorial universitaria se dispone de una lista de libros ya modelada en Scala mediante: case class Libro(titulo: String, autor: String, paginas: Int, anio: Int) val catalogo: List[Libro] = List( Libro("Programación en Scala", "Ana Ruiz", 150, 2010), Libro("Fundamentos de FP", "Juan Pérez", 165, 2011), Libro("Algoritmos Modernos", "Carlos León", 180, 2012), Libro("Estructuras de Datos", "María Gómez", 195, 2013), Libro("Introducción a la Programación", "Luis Andrade", 210, 2014), Libro("Técnicas de Depuración", "Ana Ruiz", 225, 2015), Libro("Diseño de Sistemas", "Juan Pérez", 240, 2016), Libro("Patrones de Diseño", "Carlos León", 255, 2017), Libro("Aplicaciones Web", "María Gómez", 270, 2018), Libro("Cómputo en la Nube", "Luis Andrade", 285, 2019), Libro("Arquitectura de Software", "Ana Ruiz", 300, 2015), Libro("Bases de Datos", "Juan Pérez", 315, 2016), Libro("Microservicios", "Carlos León", 330, 2017), Libro("Concurrencia en Java", "María Gómez", 345, 2018), Libro("Pruebas Automatizadas", "Luis Andrade", 360, 2019), Libro("Seguridad Aplicada", "Ana Ruiz", 375, 2016), Libro("DevOps Práctico", "Juan Pérez", 390, 2017), Libro("Análisis de Datos", "Carlos León", 405, 2018), Libro("Machine Learning Básico", "María Gómez", 420, 2019), Libro("Redes de Computadores", "Luis Andrade", 435, 2019) ) El área académica quiere identificar al autor más productivo, considerando únicamente los libros que tengan más de cierto número mínimo de páginas y que hayan sido publicados a partir de un año dado. Para organizar mejor los resultados, se desea crear en el programa una case class auxiliar que resuma la información por autor: case class AutorInfo(autor: String, totalPaginas: Int, cantidadLibros: Int) Se pide implementar un método que, a partir de la lista de Libro, devuelva un valor de tipo AutorInfo que represente al autor más productivo bajo los criterios indicados (mínimo de páginas y año mínimo). En lugar de usar funciones avanzadas como groupBy, el método debe aplicar un algoritmo manual, que se puede describir así de manera general: Primero, tomar solo los libros que cumplen las condiciones (páginas y año). A partir de esos libros filtrados, obtener la lista de autores sin repetir. Para cada autor de esa lista, recorrer la colección de libros filtrados y calcular cuántas páginas suma y cuántos libros tiene. Construir un objeto AutorInfo para cada autor con esos datos. Finalmente, recorrer la colección de AutorInfo y quedarse con aquel cuyo campo totalPaginas sea el mayor. Si no hubiera libros que cumplan las condiciones, el método debe indicar que no existe resultado.) toma en cuenta restricciones y todo lo solicitado en la instruccion e implementa de manera correcta la programacion orientada a objetos: case class Libro(titulo: String, autor: String, paginas: Int, anio: Int) case class AutorInfo(autor: String, totalPaginas: Int, cantidadLibros: Int) val catalogo: List[Libro] = List( Libro("Programación en Scala", "Ana Ruiz", 150, 2010), Libro("Fundamentos de FP", "Juan Pérez", 165, 2011), Libro("Algoritmos Modernos", "Carlos León", 180, 2012), Libro("Estructuras de Datos", "María Gómez", 195, 2013), Libro("Introducción a la Programación", "Luis Andrade", 210, 2014), Libro("Técnicas de Depuración", "Ana Ruiz", 225, 2015), Libro("Diseño de Sistemas", "Juan Pérez", 240, 2016), Libro("Patrones de Diseño", "Carlos León", 255, 2017), Libro("Aplicaciones Web", "María Gómez", 270, 2018), Libro("Cómputo en la Nube", "Luis Andrade", 285, 2019), Libro("Arquitectura de Software", "Ana Ruiz", 300, 2015), Libro("Bases de Datos", "Juan Pérez", 315, 2016), Libro("Microservicios", "Carlos León", 330, 2017), Libro("Concurrencia en Java", "María Gómez", 345, 2018), Libro("Pruebas Automatizadas", "Luis Andrade", 360, 2019), Libro("Seguridad Aplicada", "Ana Ruiz", 375, 2016), Libro("DevOps Práctico", "Juan Pérez", 390, 2017), Libro("Análisis de Datos", "Carlos León", 405, 2018), Libro("Machine Learning Básico", "María Gómez", 420, 2019), Libro("Redes de Computadores", "Luis Andrade", 435, 2019) ) def autoresSinRepetir(libros: List[Libro]): List[String] = { val autoresTodos: List[String] = libros.map((l: Libro) => l.autor) def aux(pos: Int, acumulados: List[String]): List[String] = { val n: Int = autoresTodos.size if (pos >= n) { acumulados } else { val actual: String = autoresTodos(pos) val yaEsta: Boolean = acumulados.contains(actual) val nuevoAcumulados: List[String] = if (yaEsta) acumulados else acumulados :+ actual aux(pos + 1, nuevoAcumulados) } } aux(0, List()) } def mejorAutorInfo(lista: List[AutorInfo]): AutorInfo = { def aux(pos: Int, mejor: AutorInfo): AutorInfo = { val n: Int = lista.size if (pos >= n) { mejor } else { val actual: AutorInfo = lista(pos) val nuevoMejor: AutorInfo = if (actual.totalPaginas > mejor.totalPaginas) actual else mejor aux(pos + 1, nuevoMejor) } } aux(1, lista(0)) } def autorMasProductivo( libros: List[Libro], paginasMin: Int, anioMin: Int ): AutorInfo = { val librosFiltrados: List[Libro] = libros.filter((l: Libro) => l.paginas >= paginasMin && l.anio >= anioMin) if (librosFiltrados.size == 0) { AutorInfo("Sin resultado", 0, 0) } else { val autores: List[String] = autoresSinRepetir(librosFiltrados) val listaInfo: List[AutorInfo] = autores.map((nombreAutor: String) => { val librosAutor: List[Libro] = librosFiltrados.filter((l: Libro) => l.autor == nombreAutor) val totalPaginas: Int = librosAutor.map((l: Libro) => l.paginas).sum val cantidadLibros: Int = librosAutor.size AutorInfo(nombreAutor, totalPaginas, cantidadLibros) }) val autorTop: AutorInfo = mejorAutorInfo(listaInfo) autorTop } } val resultado: AutorInfo = autorMasProductivo(catalogo, paginasMin = 200, anioMin = 2015)

Segundo prompt = 

rocura que sea un programa funcional y no imperativo y que exista la mayor eficiencia posible en el codigo debido a que se pueden optimizar muchas cosas al usar el lenguaje scala a diferencia de otros lenguajes que requieren procesos mas largos pero todo en base a las intrucciones que te entregue debido a que es muy importante lo que se plantea en la intruccion y debes seguirlo al pie de la letra
